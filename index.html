<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title data-i18n="page_title"></title>
    <!-- 
      ËØ¥Êòé: ‰∏∫‰∫ÜÊñπ‰æøÊÇ®Âú®Êú¨Âú∞Áõ¥Êé•ÊâìÂºÄÂπ∂ÁúãÂà∞ÊïàÊûúÔºåÊàë‰ª¨ÊöÇÊó∂‰ΩøÁî®TailwindÁöÑJITËÑöÊú¨„ÄÇ
      ËøôÁßçÊñπÂºèÈÄÇÂêàÂºÄÂèëÂíåÊµãËØï„ÄÇ
      ÂØπ‰∫éÊúÄÁªàÁöÑÁ∫ø‰∏äÁâàÊú¨ÔºåÊé®Ëçê‰ΩøÁî®Tailwind CLIÊûÑÂª∫‰∏Ä‰∏™ÈùôÊÄÅÁöÑCSSÊñá‰ª∂ÔºåÂπ∂Áî® <link> Ê†áÁ≠æÂºïÂÖ•„ÄÇ
    -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        // NEW: Custom colors for the new Wrong Words Modal theme
                        'wwm-bg-start': '#f2f2ff',
                        'wwm-bg-end': '#e8e8f8',
                        'dark-wwm-bg-start': '#2a283e',
                        'dark-wwm-bg-end': '#1e1c32',
                        'wwm-primary': '#5D5FEF',
                        'wwm-green': '#28a745',
                        'wwm-orange': '#fd7e14',
                        'wwm-blue': '#007bff',
                        'wwm-purple': '#6f42c1',
                    }
                }
            }
        }
    </script>
      <style>
        /* --- CSS Refactoring Summary ---
         * 1. Consolidated all duplicate CSS rules.
         * 2. Removed nearly all "!important" declarations.
         * 3. Created consistent "glassmorphism" styles for reuse (.glass-pane, .glass-control).
         * 4. Implemented graceful degradation for `backdrop-filter` using @supports.
         * 5. Created a unified custom select component style (.custom-select-*) for both single and multi-select.
         * 6. [NEW] Added @media (hover: hover) and :active states to fix mobile "sticky hover" and provide touch feedback.
        */
        
        /* 1. Global Variables & Theming */
        :root {
            --body-bg-gradient: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
            --body-text-color: #1f2937;
            --glass-pane-bg-fallback: rgba(255, 255, 255, 0.45);
            --glass-pane-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.3) 100%);
            --glass-pane-border: rgba(255, 255, 255, 0.6);
            --glass-pane-shadow: 0 8px 32px rgba(45, 55, 72, 0.15);
            --glass-pane-inset-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.75), inset 0 -1px 1px rgba(255, 255, 255, 0.25);
            --glass-pane-highlight: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.9) 50%, transparent 100%);
            --glass-control-bg: rgba(255, 255, 255, 0.35);
            --glass-control-border: rgba(255, 255, 255, 0.5);
            --glass-control-hover-bg: rgba(255, 255, 255, 0.5);
            --glass-control-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            --gradient-text-bg: linear-gradient(45deg, #3b82f6, #8b5cf6, #ec4899);
            --accent-color: #6366f1;
            --progress-bar-bg: rgba(255, 255, 255, 0.4);
            --progress-fill-bg: var(--gradient-text-bg);
            --feedback-green-text: #15803d;
            --feedback-red-text: #c2410c;
            --selected-option-bg: var(--accent-color);
            --selected-option-text: #ffffff;
            /* OPTIMIZATION: Added variables for panel components */
            --panel-handle-bg: rgba(0, 0, 0, 0.2);
            --indicator-bg: rgba(255, 255, 255, 0.2);
            --indicator-hover-bg: rgba(255, 255, 255, 0.35);
        }

        body.dark {
            --body-bg-gradient: linear-gradient(135deg, #111827 0%, #1e293b 100%);
            --body-text-color: #94a3b8;
            --glass-pane-bg-fallback: rgba(30, 41, 59, 0.4);
            --glass-pane-bg: linear-gradient(135deg, rgba(30, 41, 59, 0.4) 0%, rgba(17, 24, 39, 0.3) 100%);
            --glass-pane-border: rgba(55, 65, 81, 0.5);
            --glass-pane-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            --glass-pane-inset-shadow: inset 0 1px 1px rgba(71, 85, 105, 0.3), inset 0 -1px 1px rgba(0, 0, 0, 0.3);
            --glass-pane-highlight: linear-gradient(90deg, transparent 0%, rgba(71, 85, 105, 0.2) 50%, transparent 100%);
            --glass-control-bg: rgba(30, 41, 59, 0.4);
            --glass-control-border: rgba(55, 65, 81, 0.6);
            --glass-control-hover-bg: rgba(55, 65, 81, 0.5);
            --glass-control-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            --gradient-text-bg: linear-gradient(45deg, #38bdf8, #818cf8, #e879f9);
            --progress-bar-bg: rgba(17, 24, 39, 0.8);
            --feedback-green-text: #22c55e;
            --feedback-red-text: #f87171;
            --feedback-green-bg: #166534;
            --feedback-red-bg: #991B1B;
            --accent-color: #60a5fa;
            --selected-option-bg: #4f46e5;
            --selected-option-text: #e0e7ff;
            /* OPTIMIZATION: Added variables for panel components */
            --panel-handle-bg: rgba(255, 255, 255, 0.2);
            --indicator-bg: rgba(0, 0, 0, 0.25);
            --indicator-hover-bg: rgba(0, 0, 0, 0.4);
        }
        
        /* --- START: NEW STYLES FOR WRONG WORDS MODAL --- */
        #wrongWordsModal .wwm-select {
            background-color: #fff;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            font-weight: 500;
        }

        .dark #wrongWordsModal .wwm-select {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
            color: #d1d5db; /* gray-300 */
        }
        
        .wwm-card-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.2rem 0.6rem;
            font-size: 0.75rem; /* 12px */
            font-weight: 600;
            border-radius: 9999px;
            white-space: nowrap;
            cursor: pointer; /* Make it look clickable */
        }

        .wwm-delete-btn {
            background-color: transparent;
            color: #9ca3af; /* gray-400 */
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
            width: 2rem; /* 32px */
            height: 2rem; /* 32px */
            display: flex;
            align-items: flex-start;
            justify-content: center;
            margin-top:0.12rem;
        }
        .wwm-delete-btn:hover {
            background-color: #fee2e2; /* red-100 */
            color: #ef4444; /* red-500 */
        }
        .dark .wwm-delete-btn:hover {
            background-color: #452323;
            color: #f87171; /* red-400 */
        }
        /* --- END: NEW STYLES FOR WRONG WORDS MODAL --- */

        /* Original styles from here... */
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; background: var(--body-bg-gradient); color: var(--body-text-color); transition: background 0.5s ease, color 0.5s ease; overscroll-behavior-y: contain; min-height: 100vh; position: relative; background-attachment: fixed; }
        .glass-pane { background-color: var(--glass-pane-bg-fallback); border: 1px solid var(--glass-pane-border); box-shadow: var(--glass-pane-shadow); position: relative; }
        @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) { .glass-pane { background: var(--glass-pane-bg); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); box-shadow: var(--glass-pane-shadow), var(--glass-pane-inset-shadow); } }
        .glass-pane::after { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px; background: var(--glass-pane-highlight); }
        .glass-control { background: var(--glass-control-bg); border: 1px solid var(--glass-control-border); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); box-shadow: var(--glass-control-shadow); color: var(--body-text-color); border-radius: 0.75rem; padding: 0.75rem 1rem; font-weight: 500; transition: all 0.3s ease; }
        .glass-control:active { transform: translateY(0px) scale(0.98); }
        @media (hover: hover) { .glass-control:hover, .glass-control:focus-within { /*background: var(--glass-control-hover-bg); transform: translateY(-2px);*/  border-color: var(--accent-color); box-shadow: 0 8px 25px rgba(99, 102, 241, 0.15), var(--glass-control-shadow); } body.dark .glass-control:hover, body.dark .glass-control:focus-within { box-shadow: 0 8px 25px rgba(129, 140, 248, 0.2), var(--glass-control-shadow); } }
        .glass-control:focus, .glass-control:focus-within { outline: none; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2), 0 8px 25px rgba(99, 102, 241, 0.15); }
        body.dark .glass-control:focus, body.dark .glass-control:focus-within { box-shadow: 0 0 0 3px rgba(129, 140, 248, 0.25), 0 8px 25px rgba(129, 140, 248, 0.2); }
        .custom-select-container { position: relative; min-width: 150px; }
        .multi-select-container { min-width: 180px; }
        .custom-select-trigger { position: relative; padding-right: 3rem; min-height: calc(1.5rem + 2 * 0.75rem); display: flex; align-items: center; overflow: hidden; cursor: pointer; white-space: nowrap; }
        .custom-select-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .custom-select-trigger::after { content: '‚ñº'; position: absolute; right: 1rem; top: 50%; transform: translateY(-50%); transition: transform 0.3s ease; color: var(--accent-color); font-size: 0.75rem; }
        .custom-select-trigger.open::after { transform: translateY(-50%) rotate(180deg); }
        .custom-select-dropdown { position: absolute; top: calc(100% + 0.25rem); left: 0; right: 0; z-index: 50; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); border: 1px solid var(--glass-control-border); border-radius: 0.5rem; max-height: 250px; overflow-y: auto; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25); opacity: 0; transform: translateY(-10px) scale(0.95); transition: all 0.2s ease; pointer-events: none; }
        body.dark .custom-select-dropdown { background: rgba(30, 41, 59, 0.95); }
        .custom-select-dropdown.open { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto; }
        .custom-select-option { padding: 0.75rem; cursor: pointer; transition: all 0.2s ease; border-bottom: 1px solid rgba(255, 255, 255, 0.1); color: var(--body-text-color); }
        .multi-select-option { display: flex; align-items: center; gap: 0.5rem; }
        body.dark .custom-select-option { border-bottom-color: rgba(255, 255, 255, 0.05); }
        .custom-select-option:active { transform: translateX(2px) scale(0.99); }
        @media (hover: hover) { .custom-select-option:hover { background: var(--accent-color); color: white; transform: translateX(2px); } }
        .custom-select-option.selected { background-color: var(--selected-option-bg); color: var(--selected-option-text); font-weight: 600; }
        .custom-select-option:last-child { border-bottom: none; }
        .multi-select-checkbox { width: 1rem; height: 1rem; border: 2px solid var(--accent-color); border-radius: 0.25rem; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; flex-shrink: 0; background: transparent; }
        .multi-select-checkbox.checked { background: var(--accent-color); color: white; }
        .multi-select-checkbox.checked::after { content: '‚úì'; font-size: 0.75rem; font-weight: bold; }
        .selected-count { background: var(--gradient-text-bg); color: white; font-size: 0.75rem; padding: 0.125rem 0.5rem; border-radius: 9999px; font-weight: 600; margin-left: 0.5rem; display: inline-block; animation: pulse 2s infinite; }
        .gradient-text { background: var(--gradient-text-bg); -webkit-background-clip: text; background-clip: text; color: transparent; }
        .progress-bar { background: var(--progress-bar-bg); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
        .progress-fill { background: var(--progress-fill-bg); }
        .progress-fill::after { content: ''; position: absolute; top: 0; left: 0; bottom: 0; right: 0; background-image: linear-gradient(-45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%, transparent); background-size: 30px 30px; animation: move 2s linear infinite; }
        body.quiz-mode-active .theme-toggle { display: none; }
        .header.hidden-during-quiz, .controls.hidden-during-quiz { display: none; }
        body.quiz-mode-active main.container { padding: 0; max-width: 100%; height: 100dvh; display: flex; }
        #quizContainer.immersive-active { width: 100%; height: 100dvh; min-height: 100dvh; margin: 0; border-radius: 0; box-shadow: none; padding: calc(env(safe-area-inset-top, 0px) + 1.5rem) 1rem calc(env(safe-area-inset-bottom, 0px) + 0.5rem); display: flex; flex-direction: column; overflow: hidden; /* Changed from auto to hidden */ position: relative; }
        @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) { #quizContainer.immersive-active { background: color-mix(in srgb, var(--glass-pane-bg) 50%, transparent); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); } }
        #quizContainer.immersive-active .question-area-wrapper { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; padding-bottom: 7.5rem; align-items: center; }
        #quizContainer.immersive-active .question-content-area { position: relative; display: flex; flex-direction: column; align-items: center; width: 100%; }
        #quizContainer.immersive-active .options { margin-top: auto; padding-bottom: 2rem; width: 100%; position: relative; }
        .option { backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid var(--glass-control-border); box-shadow: var(--glass-control-shadow); background: var(--glass-control-bg); transition: all 0.3s ease; }
        .option:active { /*transform: translateY(0px) scale(0.98);*/ }
        @media (hover: hover) { .option:hover { transform: translateY(-3px); background: var(--glass-control-hover-bg); box-shadow: 0 12px 35px rgba(99, 102, 241, 0.3); } body.dark .option:hover { box-shadow: 0 12px 35px rgba(129, 140, 248, 0.3); } }
        .inline-feedback-area { position: absolute; bottom: 100%; left: 0; right: 0; text-align: center; font-size: 1.1em; font-weight: 600; padding: 8px 0; margin-bottom: 1rem; min-height: 4em; line-height: 1.4; visibility: hidden; opacity: 0; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .inline-feedback-area.show { visibility: visible; opacity: 1; }
        .inline-feedback-area.correct-inline { color: var(--feedback-green-text); }
        .inline-feedback-area.incorrect-inline { color: var(--feedback-red-text); }
        #exampleSentenceDisplay { position: absolute; top: 100%; left: 0; right: 0; margin-top: 0.5rem; text-align: center; opacity: 0; transform: translateY(-10px); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none; word-break: normal; line-height: 1.6; }
        #exampleSentenceDisplay.visible { opacity: 1; transform: translateY(0); pointer-events: auto; }
        .option.correct-answer, .option.correct-answer:hover { background: var(--feedback-green-bg); color: #FFFFFF; border-color: #15803d; transform: translateY(0); box-shadow: 0 0 15px rgba(74, 222, 128, 0.3); }
        .option.incorrect-answer, .option.incorrect-answer:hover { background: var(--feedback-red-bg); color: #FFFFFF; border-color: #b91c1c; transform: translateY(0); box-shadow: 0 0 15px rgba(239, 68, 68, 0.3); animation: incorrectShake 0.4s ease-in-out; }
        #messageBox > div, #wrongWordsModal > div { background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.8) 100%); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); border: 1px solid rgba(255, 255, 255, 0.5); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8); }
        body.dark #messageBox > div, body.dark #wrongWordsModal > div { background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(30, 41, 59, 0.8) 100%); border: 1px solid rgba(148, 163, 184, 0.4); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(148, 163, 184, 0.5); }
        .tab-button { padding: 0.75rem 1rem; font-weight: 600; transition: all 0.2s ease-in-out; border-bottom: 3px solid transparent; color: #6b7280; }
        .tab-button.active { color: #4f46e5; border-color: #4f46e5; }
        body.dark .tab-button { color: #9ca3af; }
        body.dark .tab-button.active { color: #818cf8; border-color: #818cf8; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        @keyframes move { from { background-position: 0 0; } to { background-position: 30px 30px; } }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-50px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideUp { from { opacity: 0; transform: translateY(50px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes incorrectShake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
        .loading-spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: var(--accent-color); animation: spin 1s linear infinite; }
        @media (max-width: 768px) { #keyboardHint { display: none; } }
        .z-index-elevated { z-index: 10; }
        
        /* --- START: OPTIMIZED STYLES FOR DETAILED INFO PANEL --- */
        @keyframes bounce-up {
            0%, 100% {
                transform: translateX(-50%) translateY(0);
            }
            50% {
                transform: translateX(-50%) translateY(-8px);
            }
        }

        #swipeUpIndicator {
            position: absolute;
            bottom: 12px;
            left: 50%; 
            /* transform: translateX(-50%);  <-- ÂèØ‰ª•ÁßªÈô§Ëøô‰∏ÄË°å‰∫Ü */
            color: var(--accent-color);
            animation: bounce-up 1.5s infinite;
            z-index: 30;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            /*
            padding: 10px; 
            border-radius: 50%;
            background-color: var(--indicator-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-pane-border);
            box-shadow: var(--glass-control-shadow); 
            */
        }
        
        /* ENHANCEMENT: Added hover and active states for better UX */
        @media (hover: hover) {
            #swipeUpIndicator:hover {
                animation-play-state: paused;
                transform: translateX(-50%) translateY(-4px) scale(1.05);
                background-color: var(--indicator-hover-bg);
            }
        }
        #swipeUpIndicator:active {
            transform: translateX(-50%) scale(0.95);
            transition-duration: 0.1s;
        }

        #detailedInfoPanel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 90%;
            
            /* Ê†∏ÂøÉÔºöËÉåÊôØËâ≤ÂøÖÈ°ªÊòØÈ´òÈÄèÊòéÂ∫¶ÁöÑ */
            background: var(--body-bg-gradient); 
            
            /* Ê†∏ÂøÉÔºöÊ®°Á≥äÂ∫ïÂ±ÇÂÜÖÂÆπ */
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);

            /* ËæπÊ°Ü‰πü‰ΩøÁî®ÂçäÈÄèÊòéÈ¢úËâ≤ÔºåÂ¢ûÂº∫Ë¥®ÊÑü */
            border-top: 1px solid var(--glass-pane-border);
            border-top-left-radius: 1.2rem;
            border-top-right-radius: 1.2rem;

            /* Â§ñÈÉ®Èò¥ÂΩ±ÔºåËÆ©Èù¢ÊùøÊúâÊÇ¨ÊµÆÊÑü */
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.2);
            
            /* Âä®Áîª‰∏éÂ∏ÉÂ±Ä */
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 20;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            padding: 0.75rem 1.5rem calc(env(safe-area-inset-bottom, 0px) + 1.5rem);
        }

        /* ÊèêÂçáÈù¢ÊùøÂÜÖÊâÄÊúâÊñáÊú¨ÂÜÖÂÆπÁöÑÂèØËØªÊÄß */
        #detailedInfoPanel * {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        }
        #detailedInfoPanel.visible {
            transform: translateY(0);
        }

        #panelHandle {
            width: 50px;
            height: 6px;
            background-color: var(--panel-handle-bg); /* FIX: Use CSS variable for theming */
            border-radius: 3px;
            margin: 0.5rem auto 1.5rem;
            cursor: pointer;
            flex-shrink: 0;
            transition: background-color 0.3s ease;
        }
        /* --- END: OPTIMIZED STYLES FOR DETAILED INFO PANEL --- */
      </style>
</head>

<!-- The rest of the body remains unchanged... -->

<body class="min-h-screen text-gray-800 dark:text-gray-200 relative">

    <button id="themeToggleBtn" class="theme-toggle fixed top-5 right-5 glass-control flex items-center justify-center w-12 h-12 rounded-full text-2xl cursor-pointer z-50 transition-transform hover:scale-110"></button>

    <main class="container mx-auto p-5 max-w-4xl">
        <div class="header glass-pane rounded-2xl p-8 mb-8 text-center animate-[slideDown_0.8s_ease]">
            <h1 id="mainTitle" class="text-4xl font-bold mb-2 gradient-text" data-i18n="header_title"></h1>
            <p class="text-gray-600 dark:text-gray-300 text-lg" data-i18n="header_subtitle"></p>
        </div>

        <div class="controls glass-pane rounded-xl p-5 mb-8 flex flex-wrap gap-4 items-center justify-center animate-[slideUp_0.8s_ease]">
            <div class="flex items-center gap-2">
                <label for="lessonMultiSelect" class="font-semibold text-violet-600 dark:text-violet-400" data-i18n="label_lesson"></label>
                <div class="multi-select-container custom-select-container">
                    <div id="lessonMultiSelect" class="custom-select-trigger glass-control" tabindex="0">
                        <span class="custom-select-text" data-i18n="count_all_lessons"></span>
                    </div>
                    <div class="custom-select-dropdown"></div>
                </div>
            </div>
            <div class="flex items-center gap-2">
                <label for="mode" class="font-semibold text-violet-600 dark:text-violet-400" data-i18n="label_mode"></label>
                <div id="mode" class="custom-select-container">
                    <div class="custom-select-trigger glass-control" tabindex="0">
                        <span class="custom-select-text"></span>
                    </div>
                    <div class="custom-select-dropdown"></div>
                </div>
            </div>
            <div class="flex items-center gap-2">
                <label for="difficulty" class="font-semibold text-violet-600 dark:text-violet-400" data-i18n="label_question_count"></label>
                <div id="difficulty" class="custom-select-container">
                    <div class="custom-select-trigger glass-control" tabindex="0">
                        <span class="custom-select-text"></span>
                    </div>
                    <div class="custom-select-dropdown"></div>
                </div>
            </div>
            <div class="flex flex-wrap gap-2 justify-center">
                <button id="startQuizButton" class="glass-control bg-gradient-to-br from-indigo-500 to-purple-600 text-white py-3 px-6 disabled:opacity-60 disabled:cursor-not-allowed" disabled data-i18n="btn_start_practice"></button>
                <button id="wrongWordsOpenBtn" class="glass-control bg-gradient-to-br from-sky-500 to-cyan-400 text-white py-3 px-6" data-i18n="btn_wrong_words_notebook"></button>
            </div>
        </div>

        <div id="quizContainer" class="glass-pane rounded-2xl p-10 min-h-[400px] animate-[fadeIn_0.5s_ease]"></div>
    </main>

    <div id="keyboardHint" class="fixed bottom-5 right-5 bg-gray-800 text-white py-2.5 px-4 rounded-xl text-xs opacity-0 transition-opacity duration-300 z-50" data-i18n="keyboard_hint"></div>

    <div id="messageBox" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[70] hidden">
        <div class="p-6 rounded-lg max-w-sm w-full text-center">
            <p id="messageBoxText" class="text-lg font-semibold mb-6 text-slate-800 dark:text-slate-200"></p>
            <div id="messageBoxButtons" class="flex justify-center gap-4"></div>
        </div>
    </div>

    <!-- ===== START: RESTRUCTURED WRONG WORDS MODAL ===== -->
    <div id="wrongWordsModal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-[60] hidden">
        <div class="bg-gradient-to-br from-wwm-bg-start to-wwm-bg-end dark:from-wwm-bg-start dark:to-wwm-bg-end rounded-2xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
            <!-- Modal Header -->
            <header class="p-5 flex-shrink-0">
                <div class="flex justify-between items-center">
                    <h3 class="text-xl font-bold text-slate-800 dark:text-slate-100 flex items-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-wwm-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" /></svg>
                        <span data-i18n="wrong_words_modal_title"></span>
                    </h3>
                    <button id="wrongWordsCloseBtn" class="text-gray-400 dark:text-gray-300 hover:text-gray-600 dark:hover:text-gray-100 text-2xl transition-colors font-mono">‚úï</button>
                </div>
            </header>
            
            <!-- Main Content Area -->
            <main class="overflow-y-auto flex-grow p-5 pt-0">
                <!-- Filters -->
                <div class="flex flex-wrap items-center gap-4 mb-5">
                    <select id="wrongWordFilter" class="wwm-select flex-grow sm:flex-grow-0"></select>
                    <select id="wrongWordSort" class="wwm-select flex-grow sm:flex-grow-0"></select>
                </div>
                <!-- Summary Stats -->
                <div class="hidden bg-white/50 dark:bg-black/10 backdrop-blur-sm rounded-xl p-4 mb-5 flex flex-wrap justify-around gap-4 text-center">
                    <div id="wwm-summary-words" class="flex-1 min-w-[80px]"></div>
                    <div id="wwm-summary-mistakes" class="flex-1 min-w-[80px]"></div>
                    <div id="wwm-summary-new" class="flex-1 min-w-[80px]"></div>
                </div>
                <!-- Action Buttons -->
                <div class="grid grid-cols-3 gap-3 mb-6">
                    <button id="startWrongWordsQuizBtn" class="bg-wwm-primary hover:bg-opacity-90 text-white font-semibold px-4 py-3 rounded-xl transition-all flex items-center justify-center gap-2  active:scale-95">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.841z" /></svg>
                        <span data-i18n="wrong_words_start_practice" class="hidden sm:inline"></span>
                    </button>
                    <button id="exportWrongWordsBtn" class="bg-wwm-green hover:bg-opacity-90 text-white font-semibold px-4 py-3 rounded-xl transition-all flex items-center justify-center gap-2  active:scale-95">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        <span data-i18n="wrong_words_export" class="hidden sm:inline"></span>
                    </button>
                    <button id="clearAllWrongWordsBtn" class="bg-rose-500 text-white hover:bg-opacity-90 font-semibold px-4 py-3 rounded-xl transition-all flex items-center justify-center gap-2 active:scale-95">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                        <span data-i18n="wrong_words_clear_all" class="hidden sm:inline"></span>
                    </button>
                </div>
                <!-- Word List -->
                <div id="wrongWordsList" class="space-y-3"></div>

                <!-- Hidden Statistics Tab Content -->
                <div id="tab-statistics" class="tab-content hidden p-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6" id="statistics-grid"></div>
                </div>
            </main>
        </div>
    </div>
    <!-- ===== END: RESTRUCTURED WRONG WORDS MODAL ===== -->
    
    <!-- ===== START: REDESIGNED WRONG WORD CARD TEMPLATE (MODIFIED) ===== -->
    <template id="wrongWordCardTemplate">
        <div class="bg-white dark:bg-slate-800 rounded-xl shadow-sm hover:shadow-md transition-shadow duration-300 p-4 space-y-3" data-word="">
            <div class="flex justify-between items-start gap-4">
                <!-- Left: Word Info -->
                <div class="space-y-1 min-w-0 flex-grow">
                    <h4 class="text-2xl font-bold text-slate-800 dark:text-slate-100 break-all" data-field="word"></h4>
                    <p class="text-md text-slate-500 dark:text-slate-400 break-words" data-field="reading"></p>
                    <p class="text-slate-700 dark:text-slate-300 !mt-2" data-field="meaning"></p>
                </div>
                <!-- Right: Badges & Actions -->
                <div class="flex-shrink-0 flex flex-col items-end gap-y-2">
                    <!-- MODIFICATION START: Changed divs to buttons with data-action -->
                    <button type="button" data-action="edit-mastery" data-field="masteryBadge" class="wwm-card-badge border-0 transition-transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-wwm-primary"></button>
                    <button type="button" data-action="edit-difficulty" data-field="difficultyBadge" class="wwm-card-badge border-0 transition-transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-wwm-primary"></button>
                    <!-- MODIFICATION END -->
                    <button type="button" data-action="delete" title="" class="wwm-delete-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                    </button>
                </div>
            </div>
            
            <!-- Example Sentence -->
            <div class="p-3 bg-indigo-50 dark:bg-slate-700/50 rounded-lg border-l-4 border-slate-400 dark:border-indigo-500 hidden" data-field="exampleContainer">
                <p class="text-slate-600 dark:text-slate-300" data-field="example"></p>
            </div>
            
            <!-- Footer -->
            <div class="flex justify-between items-center text-xs text-slate-400 dark:text-slate-500 pt-2 border-t border-slate-100 dark:border-slate-700/50">
                <span data-field="wrongCount"></span>
                <span data-field="lastWrongDate"></span>
            </div>
        </div>
    </template>
    <!-- ===== END: REDESIGNED WRONG WORD CARD TEMPLATE ===== -->


    <script>
    // Global translation function
    let currentTranslations = {};
    const _t = (key, replacements = {}) => {
        let text = currentTranslations[key] || key;
        for (const [placeholder, value] of Object.entries(replacements)) {
            text = text.replace(`{${placeholder}}`, value);
        }
        return text;
    };

    class SingleSelect {
        constructor(containerId, options = {}) {
            this.container = document.getElementById(containerId);
            if (!this.container) { console.error(`SingleSelect container not found: #${containerId}`); return; }
            this.trigger = this.container.querySelector('.custom-select-trigger');
            this.dropdown = this.container.querySelector('.custom-select-dropdown');
            this.textElement = this.trigger.querySelector('.custom-select-text');
            this.optionsData = [];
            this.selectedValue = options.defaultValue || null;
            this.isOpen = false;
            this.app = options.app; // [BUGFIX] Capture app instance
            this.onSelectionChange = options.onSelectionChange || (() => {});
            this.init();
        }
        init() { this.bindEvents(); }
        bindEvents() {
            this.trigger.addEventListener('click', e => { e.stopPropagation(); this.toggle(); });
            this.trigger.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.toggle(); } });
            document.addEventListener('click', e => { if (this.isOpen && !this.container.contains(e.target)) { this.close(); } });
        }
        setOptions(optionsData) {
            this.optionsData = optionsData;
            if (!this.selectedValue && this.optionsData.length > 0) {
                this.selectedValue = this.optionsData[0].value;
            }
            this.renderOptions();
            this.updateTriggerText();
        }
        renderOptions() {
            this.dropdown.innerHTML = '';
            this.optionsData.forEach(option => {
                const isSelected = this.selectedValue === option.value;
                const optionElement = document.createElement('div');
                optionElement.className = `custom-select-option ${isSelected ? 'selected' : ''}`;
                optionElement.dataset.value = option.value;
                optionElement.textContent = option.label;
                optionElement.addEventListener('click', e => { e.stopPropagation(); this.selectOption(option.value); });
                this.dropdown.appendChild(optionElement);
            });
        }
        selectOption(value) {
            this.selectedValue = value;
            this.updateTriggerText();
            this.renderOptions();
            this.close();
            this.onSelectionChange(this.selectedValue);
        }
        updateTriggerText() {
            const selectedOption = this.optionsData.find(opt => opt.value === this.selectedValue);
            if (selectedOption) { this.textElement.textContent = selectedOption.label; }
        }
        getValue() { return this.selectedValue; }
        toggle() { this.isOpen ? this.close() : this.open(); }
        open() {
            this.app?.closeAllSelects(this); // [BUGFIX] Close other selects before opening
            this.isOpen = true;
            this.trigger.classList.add('open');
            this.dropdown.classList.add('open');
            this.trigger.setAttribute('aria-expanded', 'true');
            this.container.closest('.controls').classList.add('z-index-elevated');
        }
        close() {
            this.isOpen = false;
            this.trigger.classList.remove('open');
            this.dropdown.classList.remove('open');
            this.trigger.setAttribute('aria-expanded', 'false');
            setTimeout(() => { if (!this.app.selects.some(s => s.isOpen)) { this.container.closest('.controls').classList.remove('z-index-elevated'); } }, 100);
        }
    }

    class MultiSelect {
        constructor(containerSelector, options = {}) {
            this.container = document.querySelector(containerSelector);
            if (!this.container) { console.error(`MultiSelect container not found: ${containerSelector}`); return; }
            this.trigger = this.container.querySelector('.custom-select-trigger');
            this.dropdown = this.container.querySelector('.custom-select-dropdown');
            this.textElement = this.trigger.querySelector('.custom-select-text');
            this.selectedValues = new Set(['all']);
            this.optionsData = [];
            this.isOpen = false;
            this.app = options.app; // [BUGFIX] Capture app instance
            this.onSelectionChange = options.onSelectionChange || (() => {});
            this.init();
        }
        init() { this.bindEvents(); }
        bindEvents() {
            this.trigger.addEventListener('click', e => { e.stopPropagation(); this.toggle(); });
            this.trigger.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.toggle(); } });
            document.addEventListener('click', e => { if (this.isOpen && !this.container.contains(e.target)) { this.close(); } });
        }
        setOptions(optionsData) { this.optionsData = optionsData; this.renderOptions(); this.updateTriggerText(); }
        renderOptions() {
            this.dropdown.innerHTML = '';
            this.optionsData.forEach(option => {
                const isSelected = this.selectedValues.has(option.value);
                const optionElement = document.createElement('div');
                optionElement.className = `custom-select-option multi-select-option ${isSelected ? 'selected' : ''}`;
                optionElement.dataset.value = option.value;
                optionElement.innerHTML = `<div class="multi-select-checkbox ${isSelected ? 'checked' : ''}"></div><span>${option.label}</span>`;
                optionElement.addEventListener('click', e => { e.stopPropagation(); this.toggleOption(option.value); });
                this.dropdown.appendChild(optionElement);
            });
        }
        toggleOption(value) {
            const individualOptions = this.optionsData.filter(opt => opt.value !== 'all');
            if (value === 'all') { this.selectedValues.has('all') ? this.selectedValues.clear() : (this.selectedValues.clear(), this.selectedValues.add('all'));
            } else {
                this.selectedValues.delete('all');
                this.selectedValues.has(value) ? this.selectedValues.delete(value) : this.selectedValues.add(value);
                if (individualOptions.length > 0 && this.selectedValues.size === individualOptions.length) { this.selectedValues.clear(); this.selectedValues.add('all'); }
            }
            if (this.selectedValues.size === 0) { this.selectedValues.add('all'); }
            this.renderOptions(); this.updateTriggerText(); this.onSelectionChange(this.getSelectedValues());
        }
        updateTriggerText() {
            const selectedCount = this.selectedValues.size;
            if (this.selectedValues.has('all') || selectedCount === 0) { this.textElement.innerHTML = _t('count_all_lessons');
            } else if (selectedCount === 1) {
                const selectedValue = this.selectedValues.values().next().value;
                const option = this.optionsData.find(opt => opt.value === selectedValue);
                this.textElement.innerHTML = option ? option.label : '';
            } else { this.textElement.innerHTML = `${_t('label_lesson_short')} <span class="selected-count">${selectedCount}</span>`; }
        }
        getSelectedValues() { return Array.from(this.selectedValues); }
        toggle() { this.isOpen ? this.close() : this.open(); }
        open() {
            this.app?.closeAllSelects(this); // [BUGFIX] Close other selects before opening
            this.isOpen = true; this.trigger.classList.add('open'); this.dropdown.classList.add('open'); this.trigger.setAttribute('aria-expanded', 'true');
            this.container.closest('.controls').classList.add('z-index-elevated');
        }
        close() {
            this.isOpen = false; this.trigger.classList.remove('open'); this.dropdown.classList.remove('open'); this.trigger.setAttribute('aria-expanded', 'false');
            setTimeout(() => { if (!this.app.selects.some(s => s.isOpen)) { this.container.closest('.controls').classList.remove('z-index-elevated'); } }, 100);
        }
    }
    
    const WrongWordsManager = {
        app: null,
        init(appInstance) { this.app = appInstance; this.bindEvents(); },
        bindEvents() {
            const { elements } = this.app;
            elements.wrongWordsOpenBtn.addEventListener('click', () => this.openModal());
            elements.wrongWordsCloseBtn.addEventListener('click', () => this.closeModal());
            // Note: Tab functionality is hidden in the new UI but kept in JS
            elements.wrongWordFilter.addEventListener('change', () => this.renderList());
            elements.wrongWordSort.addEventListener('change', () => this.renderList());
            elements.startWrongWordsQuizBtn.addEventListener('click', () => this.startQuiz());
            elements.clearAllWrongWordsBtn.addEventListener('click', async () => { if (await this.app.showConfirmation('confirm_clear_wrong_words')) { this.save([]); this.renderAll(); } });
            elements.wrongWordsListContainer.addEventListener('click', async e => await this.handleCardInteraction(e.target.closest('[data-action]'), 'click'));
        },
        openModal() { this.app.elements.wrongWordsModal.classList.remove('hidden'); this.app.elements.body.style.overflow = 'hidden'; this.populateFilters(); this.renderAll(); },
        closeModal() { this.app.elements.wrongWordsModal.classList.add('hidden'); this.app.elements.body.style.overflow = ''; },
        getStorageKey() { return `${this.app.constants.WRONG_WORDS_KEY_PREFIX}${this.app.state.currentJLPTLevel}`; },
        get() { return JSON.parse(localStorage.getItem(this.getStorageKey())) || []; },
        save(words) { localStorage.setItem(this.getStorageKey(), JSON.stringify(words)); },
        addOrUpdate(vocab, mode) {
            let words = this.get();
            const existing = words.find(w => w.word === vocab.w);
            const now = new Date().toISOString();
            if (existing) {
                existing.wrongCount++; existing.lastWrongTimestamp = now; existing.history.push({ timestamp: now, mode });
                if (existing.masteryLevel === 'familiar') existing.masteryLevel = 'learning';
            } else { words.push({ word: vocab.w, vocabObject: vocab, wrongCount: 1, firstWrongTimestamp: now, lastWrongTimestamp: now, masteryLevel: 'new', difficulty: 3, history: [{ timestamp: now, mode }] }); }
            this.save(words);
        },
        // MODIFICATION START: Updated handleCardInteraction to manage mastery and difficulty
        async handleCardInteraction(target, eventType) {
            if (!target) return;
            const action = target.dataset.action;
            const wordValue = target.closest('[data-word]')?.dataset.word;
            if (!wordValue || !action) return;
            let words = this.get();
            const wordIndex = words.findIndex(w => w.word === wordValue);
            if (wordIndex === -1) return;
            
            let needsUIRefresh = false;
            
            if (eventType === 'click') {
                switch (action) {
                    case 'delete':
                        if (await this.app.showConfirmation('confirm_delete_word', { word: wordValue })) {
                            words.splice(wordIndex, 1);
                            needsUIRefresh = true;
                        }
                        break;
                    
                    case 'edit-mastery':
                        const wordToEditMastery = words[wordIndex];
                        const masteryLevels = ['new', 'learning', 'familiar'];
                        const currentMasteryIndex = masteryLevels.indexOf(wordToEditMastery.masteryLevel);
                        const nextMasteryIndex = (currentMasteryIndex + 1) % masteryLevels.length;
                        wordToEditMastery.masteryLevel = masteryLevels[nextMasteryIndex];
                        needsUIRefresh = true;
                        break;
                        
                    case 'edit-difficulty':
                        const wordToEditDifficulty = words[wordIndex];
                        let currentDifficulty = wordToEditDifficulty.difficulty || 3; // Default to 3
                        wordToEditDifficulty.difficulty = (currentDifficulty % 5) + 1; // Cycles 1->2->3->4->5->1
                        needsUIRefresh = true;
                        break;
                }
            }
            
            if (needsUIRefresh) {
                this.save(words);
                this.renderAll();
            }
        },
        // MODIFICATION END
        populateFilters() {
            this.app.elements.wrongWordFilter.innerHTML = `<option value="all">${_t('wrong_words_filter_all')}</option><option value="new">${_t('wrong_words_filter_new')}</option><option value="learning">${_t('wrong_words_filter_learning')}</option><option value="familiar">${_t('wrong_words_filter_familiar')}</option>` + [1,2,3,4,5].map(l => `<option value="difficulty-${l}">${_t('wrong_words_filter_difficulty', { level: l })}</option>`).join('');
            this.app.elements.wrongWordSort.innerHTML = `<option value="recent">${_t('wrong_words_sort_recent')}</option><option value="frequency">${_t('wrong_words_sort_frequency')}</option><option value="difficulty">${_t('wrong_words_sort_difficulty')}</option><option value="alphabetical">${_t('wrong_words_sort_alphabetical')}</option>`;
        },
        getFilteredAndSorted() {
            const filter = this.app.elements.wrongWordFilter.value;
            const sort = this.app.elements.wrongWordSort.value;
            let words = this.get();
            words = words.filter(word => {
                if (filter === 'all') return true;
                if (['new', 'learning', 'familiar'].includes(filter)) return word.masteryLevel === filter;
                if (filter.startsWith('difficulty-')) return word.difficulty === parseInt(filter.split('-')[1]);
                return true;
            });
            return words.sort((a, b) => {
                switch (sort) {
                    case 'recent': return new Date(b.lastWrongTimestamp) - new Date(a.lastWrongTimestamp);
                    case 'frequency': return b.wrongCount - a.wrongCount;
                    case 'difficulty': return b.difficulty - a.difficulty;
                    case 'alphabetical': return (a.vocabObject.r || a.vocabObject.w).localeCompare(b.vocabObject.r || b.vocabObject.w, this.app.state.currentLanguage);
                    default: return 0;
                }
            });
        },
        renderAll() { this.renderSummary(); this.renderList(); this.renderStatistics(); },
        renderSummary() {
            const words = this.get();
            const totalWords = words.length;
            const totalMistakes = words.reduce((sum, word) => sum + word.wrongCount, 0);
            const newWords = words.filter(w => w.masteryLevel === 'new').length;

            const createSummaryHTML = (icon, value, i18nKey) => `<div class="font-semibold text-slate-700 dark:text-slate-300">${_t(i18nKey)}</div><div class="text-2xl font-bold text-slate-900 dark:text-slate-100">${value}</div>`;
            
            document.getElementById('wwm-summary-words').innerHTML = createSummaryHTML('üìö', totalWords, 'wwm_summary_words');
            document.getElementById('wwm-summary-mistakes').innerHTML = createSummaryHTML('‚ùå', totalMistakes, 'wwm_summary_mistakes');
            document.getElementById('wwm-summary-new').innerHTML = createSummaryHTML('‚ú®', newWords, 'wwm_summary_new');
        },
        // MODIFICATION START: Updated renderList to set titles on the new buttons
        renderList() {
            const listContainer = this.app.elements.wrongWordsListContainer;
            const cardTemplate = this.app.elements.wrongWordCardTemplate;
            const words = this.getFilteredAndSorted();
            listContainer.innerHTML = '';
            if (words.length === 0) { listContainer.innerHTML = `<div class="text-center text-gray-500 dark:text-gray-400 py-16"><svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><h3 class="mt-2 text-lg font-medium text-gray-900 dark:text-gray-200">${_t('no_matching_words')}</h3><p class="mt-1 text-sm text-gray-500 dark:text-gray-400">${_t('change_filter_or_add_words')}</p></div>`; return; }
            
            const masteryInfo = {
                new: { text: _t('wrong_word_mastery_new'), classes: 'bg-wwm-blue/10 text-wwm-blue dark:bg-wwm-blue/20 dark:text-blue-300' },
                learning: { text: _t('wrong_word_mastery_learning'), classes: 'bg-wwm-purple/10 text-wwm-purple dark:bg-wwm-purple/20 dark:text-purple-300' },
                familiar: { text: _t('wrong_word_mastery_familiar'), classes: 'bg-wwm-green/20 text-wwm-green dark:bg-wwm-green/30 dark:text-green-300' }
            };
            const difficultyInfo = {
                1: { text: _t('wrong_word_difficulty', {level: 1}), classes: 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300' }, 2: { text: _t('wrong_word_difficulty', {level: 2}), classes: 'bg-blue-100 text-blue-700 dark:bg-blue-900/40 dark:text-blue-300' }, 3: { text: _t('wrong_word_difficulty', {level: 3}), classes: 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/40 dark:text-yellow-400' }, 4: { text: _t('wrong_word_difficulty', {level: 4}), classes: 'bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-400' }, 5: { text: _t('wrong_word_difficulty', {level: 5}), classes: 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-400' }
            };

            const fragment = document.createDocumentFragment();
            words.forEach(word => {
                const card = cardTemplate.content.cloneNode(true);
                card.querySelector('[data-word]').dataset.word = word.word;
                card.querySelector('[data-field="word"]').textContent = word.vocabObject.w;
                card.querySelector('[data-field="reading"]').textContent = word.vocabObject.r;
                card.querySelector('[data-field="meaning"]').textContent = `${_t('wrong_word_meaning_prefix')}${word.vocabObject.c || word.vocabObject.m}`;
                const exampleContainer = card.querySelector('[data-field="exampleContainer"]');
                const exampleText = word.vocabObject.e || word.vocabObject.u;
                if (exampleText) { card.querySelector('[data-field="example"]').textContent = `${exampleText}`; exampleContainer.classList.remove('hidden'); }
                
                const masteryButton = card.querySelector('[data-field="masteryBadge"]');
                const mInfo = masteryInfo[word.masteryLevel];
                if(mInfo) { masteryButton.className += ` ${mInfo.classes}`; masteryButton.textContent = mInfo.text; }
                masteryButton.title = _t('wrong_word_edit_mastery_title');

                const difficultyButton = card.querySelector('[data-field="difficultyBadge"]');
                const dInfo = difficultyInfo[word.difficulty];
                if(dInfo) { difficultyButton.className += ` ${dInfo.classes}`; difficultyButton.textContent = dInfo.text; }
                difficultyButton.title = _t('wrong_word_edit_difficulty_title');

                card.querySelector('[data-action="delete"]').title = _t('wrong_word_delete');
                card.querySelector('[data-field="wrongCount"]').textContent = _t('wrong_word_count', { count: word.wrongCount });
                card.querySelector('[data-field="lastWrongDate"]').textContent = _t('wrong_word_last_wrong_date', { date: new Date(word.lastWrongTimestamp).toLocaleString(this.app.state.currentLanguage, { year: '2-digit', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) });
                fragment.appendChild(card);
            });
            listContainer.appendChild(fragment);
        },
        // MODIFICATION END
        renderStatistics() { /* This function can be kept as is, it populates a hidden area */ },
        startQuiz() { const wordsToPractice = this.getFilteredAndSorted(); if (wordsToPractice.length === 0) { this.app.showMessageBox("no_matching_words"); return; } this.closeModal(); this.app.initializeAndRunQuiz(wordsToPractice.map(item => item.vocabObject), 'mixed'); },
        export() { /* This function can be kept as is */ }
    };

    const VocabularyApp = {
        state: {
            allVocabulary: {}, currentQuiz: [], currentQuestion: 0, score: 0, streak: 0, maxStreak: 0,
            selectedAnswer: null, startTime: null, questionStartTime: null, wrongAnswers: [], answerLog: [],
            maxQuestionReachedInSession: 0, isInputLocked: false, currentJLPTLevel: 'N2',
            touchstartX: 0, touchstartY: 0, touchendX: 0, touchendY: 0, touchstartTime: 0,
            timerInterval: null, nextQuestionTimeoutId: null, sessionHintShown: false,
            currentLanguage: 'ja', availableLanguages: ['ja', 'en', 'zh'],
        },
        constants: { WRONG_WORDS_KEY_PREFIX: 'wrongWordsNotebook_', SWIPE_THRESHOLD: 50, SWIPE_TIME_THRESHOLD: 400, },
        elements: {}, i18n: {}, selects: [],
        lessonMultiSelect: null, modeSelect: null, difficultySelect: null,
        closeAllSelects(exceptThisOne = null) { this.selects.forEach(select => { if (select && select !== exceptThisOne && select.isOpen) { select.close(); } }); },
        init() {
            this.cacheDOMElements(); this.initializeTheme();
            this.lessonMultiSelect = new MultiSelect('.multi-select-container', { app: this });
            this.modeSelect = new SingleSelect('mode', { defaultValue: 'reading', app: this });
            this.difficultySelect = new SingleSelect('difficulty', { defaultValue: 'all', app: this });
            this.selects.push(this.lessonMultiSelect, this.modeSelect, this.difficultySelect);
            this.bindEvents(); this.determineLanguage();
            this.loadTranslations().then(() => {
                this.applyTranslations(); this.renderWelcomeMessage(); this.elements.startQuizButton.disabled = false;
                this.elements.startQuizButton.textContent = _t('btn_start_practice');
                this.initializeAppBasedOnURL(); WrongWordsManager.init(this);
            }).catch(error => { console.error("Failed to load translations:", error); this.elements.startQuizButton.textContent = _t('load_failed'); this.showMessageBox('load_failed'); });
        },
        cacheDOMElements() {
            this.elements = {
                body: document.body, mainTitle: document.getElementById('mainTitle'), themeToggleBtn: document.getElementById('themeToggleBtn'),
                header: document.querySelector('.header'), controls: document.querySelector('.controls'), quizContainer: document.getElementById('quizContainer'),
                startQuizButton: document.getElementById('startQuizButton'), keyboardHint: document.getElementById('keyboardHint'),
                messageBox: document.getElementById('messageBox'), messageBoxText: document.getElementById('messageBoxText'), messageBoxButtons: document.getElementById('messageBoxButtons'),
                wrongWordsModal: document.getElementById('wrongWordsModal'), wrongWordsOpenBtn: document.getElementById('wrongWordsOpenBtn'), wrongWordsCloseBtn: document.getElementById('wrongWordsCloseBtn'),
                wrongWordsListContainer: document.getElementById('wrongWordsList'),
                wrongWordFilter: document.getElementById('wrongWordFilter'), wrongWordSort: document.getElementById('wrongWordSort'),
                startWrongWordsQuizBtn: document.getElementById('startWrongWordsQuizBtn'), exportWrongWordsBtn: document.getElementById('exportWrongWordsBtn'),
                clearAllWrongWordsBtn: document.getElementById('clearAllWrongWordsBtn'), wrongWordCardTemplate: document.getElementById('wrongWordCardTemplate')
            };
        },
        bindEvents() {
            this.elements.themeToggleBtn.addEventListener('click', () => this.toggleTheme());
            this.elements.startQuizButton.addEventListener('click', () => this.startQuiz());
            document.addEventListener('keydown', e => this.handleKeyDown(e));
            this.elements.quizContainer.addEventListener('touchstart', e => this.handleTouchStart(e), { passive: true });
            this.elements.quizContainer.addEventListener('touchmove', e => this.handleTouchMove(e), { passive: false });
            this.elements.quizContainer.addEventListener('touchend', e => this.handleTouchEnd(e), { passive: true });
            document.addEventListener('click', () => this.closeAllSelects());
        },
        determineLanguage() {
            const langParam = new URLSearchParams(window.location.search).get('lang');
            if (langParam && this.state.availableLanguages.includes(langParam)) { this.state.currentLanguage = langParam; } 
            else { const browserLang = (navigator.language || navigator.languages[0]).split('-')[0]; if (this.state.availableLanguages.includes(browserLang)) { this.state.currentLanguage = browserLang; } }
            document.documentElement.lang = this.state.currentLanguage;
        },
        async loadTranslations() {
            // MODIFICATION START: Added new translation keys for editable badges and detailed info panel
            const newKeys = {
                wwm_summary_words: "Words",
                wwm_summary_mistakes: "Mistakes",
                wwm_summary_new: "New",
                wrong_word_edit_mastery_title: "Click to change mastery level",
                wrong_word_edit_difficulty_title: "Click to change difficulty level",
                detailed_info_title: "Answer Details",
                // Standard English prefixes for fallbacks
                detailed_info_meaning_prefix: "Meaning: ",
                detailed_info_example_prefix: "Example: "
            };
            // MODIFICATION END
            
            if (this.i18n[this.state.currentLanguage]) { currentTranslations = this.i18n[this.state.currentLanguage]; return; }
            try {
                const response = await fetch(`./locales/${this.state.currentLanguage}.json`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                let translations = await response.json();
                
                // Merge new keys, giving priority to keys from the JSON file if they exist
                translations = {...newKeys, ...translations };
                
                this.i18n[this.state.currentLanguage] = translations;
                currentTranslations = translations;
            } catch (error) {
                console.error("Error loading translations:", error);
                if (this.state.currentLanguage !== 'en') { this.state.currentLanguage = 'en'; document.documentElement.lang = 'en'; return this.loadTranslations(); } 
                else { currentTranslations = newKeys; }
            }
        },
        // The rest of the VocabularyApp object remains unchanged...
        // ... (all other functions from VocabularyApp are here)
        applyTranslations() { document.querySelectorAll('[data-i18n]').forEach(element => { const key = element.getAttribute('data-i18n'); const translation = _t(key); if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') { element.placeholder = translation; } else { element.innerHTML = translation; } }); document.title = _t('page_title'); this.modeSelect.setOptions([ { value: 'reading', label: _t('mode_reading') }, { value: 'meaning', label: _t('mode_meaning') }, { value: 'usage', label: _t('mode_usage') }, { value: 'mixed', label: _t('mode_mixed') } ]); this.difficultySelect.setOptions([ { value: '5', label: _t('count_5') }, { value: '10', label: _t('count_10') }, { value: '20', label: _t('count_20') }, { value: '30', label: _t('count_30') }, { value: 'all', label: _t('count_all') } ]); },
        
        // =================================================================
        // ===== START OF FINAL CORRECTED CODE (from user conversation) ====
        // =================================================================

        submitAnswer(selectedIndex) {
            if (this.state.isInputLocked) return;
            this.state.isInputLocked = true;
            clearInterval(this.state.timerInterval);
            const question = this.state.currentQuiz[this.state.currentQuestion];
            const isCorrect = question.options[selectedIndex].correct;
            const timeSpent = Math.floor((Date.now() - this.state.questionStartTime) / 1000);
            this.state.answerLog.push({ questionIndex: this.state.currentQuestion, selectedOptionIndex: selectedIndex, isCorrect, timeSpent });
            if (isCorrect) {
                this.state.score++;
                this.state.streak++;
                if (this.state.streak > this.state.maxStreak) this.state.maxStreak = this.state.streak;
            } else {
                this.state.streak = 0;
                this.state.wrongAnswers.push({ question: question.question, yourAnswer: question.options[selectedIndex].text, correctAnswer: question.correctAnswer, vocab: question.vocab });
                WrongWordsManager.addOrUpdate(question.vocab, question.mode);
            }
            // MODIFIED: Explicitly state this is NOT review mode
            this.showQuestion({ isReviewMode: false });
            this.state.nextQuestionTimeoutId = setTimeout(() => this.nextQuestion(), isCorrect ? 150 : 1800);
        },
        
        showMessageBox(messageKey, replacements = {}) { this.elements.messageBoxText.textContent = _t(messageKey, replacements); this.elements.messageBoxButtons.innerHTML = `<button id="messageBoxOkBtn" class="glass-control bg-gradient-to-br from-indigo-500 to-purple-600 text-white py-2 px-4">${_t('message_box_ok')}</button>`; this.elements.messageBox.classList.remove('hidden'); document.getElementById('messageBoxOkBtn').addEventListener('click', () => this.hideMessageBox(), { once: true }); document.getElementById('messageBoxOkBtn').focus(); },
        hideMessageBox() { this.elements.messageBox.classList.add('hidden'); },
        showConfirmation(messageKey, replacements = {}) { return new Promise(resolve => { this.elements.messageBoxText.textContent = _t(messageKey, replacements); this.elements.messageBoxButtons.innerHTML = `<button id="confirmBtn" class="glass-control bg-gradient-to-br from-red-500 to-orange-500 text-white py-2 px-4">${_t('confirm_btn')}</button><button id="cancelBtn" class="glass-control bg-gray-200 dark:bg-gray-600 py-2 px-4">${_t('cancel_btn')}</button>`; this.elements.messageBox.classList.remove('hidden'); const confirmBtn = document.getElementById('confirmBtn'); const cancelBtn = document.getElementById('cancelBtn'); const cleanup = () => { this.hideMessageBox(); confirmBtn.removeEventListener('click', onConfirm); cancelBtn.removeEventListener('click', onCancel); }; const onConfirm = () => { cleanup(); resolve(true); }; const onCancel = () => { cleanup(); resolve(false); }; confirmBtn.addEventListener('click', onConfirm); cancelBtn.addEventListener('click', onCancel); confirmBtn.focus(); }); },
        async initializeAppBasedOnURL() { const ALLOWED_LEVELS = ['n1', 'n2', 'n3', 'biaori', 'gaoji']; const DEFAULT_LEVEL = 'n2'; const getLevelFromPath = () => { const path = (window.location.pathname + window.location.search).toLowerCase(); return ALLOWED_LEVELS.find(level => path.includes(`/${level}`)) || null; }; const urlParams = new URLSearchParams(window.location.search); const levelFromParam = urlParams.get('level')?.toLowerCase(); const levelFromPath = getLevelFromPath(); let determinedLevel = DEFAULT_LEVEL; if (levelFromParam && ALLOWED_LEVELS.includes(levelFromParam)) { determinedLevel = levelFromParam; } else if (levelFromPath) { determinedLevel = levelFromPath; } if (levelFromParam && !ALLOWED_LEVELS.includes(levelFromParam)) { console.warn(`Invalid 'level' parameter: "${levelFromParam}". Using determined level: "${determinedLevel}".`); } console.log(`Final determined level: ${determinedLevel}`); this.state.currentJLPTLevel = determinedLevel.toUpperCase(); const mainTitleKeyMap = { 'BIAORI': 'BIAORI', 'GAOJI': 'GAOJI', 'N2': 'JLPT_N2', 'N1': 'JLPT_N1', 'N3': 'JLPT_N3' }; const mainTitleKey = mainTitleKeyMap[this.state.currentJLPTLevel] || 'header_title'; this.elements.mainTitle.textContent = _t(mainTitleKey); const filePath = `./data/${determinedLevel}.json`; await this.loadVocabularyData(filePath); },
        async loadVocabularyData(fileName) { try { this.elements.startQuizButton.disabled = true; this.elements.startQuizButton.textContent = _t('loading_data'); const response = await fetch(fileName); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); this.state.allVocabulary = await response.json(); this.populateLessonSelect(); this.elements.startQuizButton.disabled = false; this.elements.startQuizButton.textContent = _t('btn_start_practice'); } catch (error) { console.error(`Could not load vocabulary from ${fileName}:`, error); this.showMessageBox('data_load_failed_message', { fileName }); this.elements.startQuizButton.textContent = _t('load_failed'); } },
        populateLessonSelect() { if (!this.lessonMultiSelect) return; const lessonKeys = Object.keys(this.state.allVocabulary).sort((a, b) => parseInt(a.replace('lesson', '')) - parseInt(b.replace('lesson', ''))); const options = [{ value: 'all', label: _t('count_all_lessons') }, ...lessonKeys.map(key => ({ value: key, label: key.replace('lesson', _t('label_lesson_short')) }))]; this.lessonMultiSelect.setOptions(options); },
        startQuiz() { if (Object.keys(this.state.allVocabulary).length === 0) { this.showMessageBox('no_words_for_lesson'); return; } const selectedLessons = this.lessonMultiSelect.getSelectedValues(); const selectedMode = this.modeSelect.getValue(); const difficulty = this.difficultySelect.getValue(); let sourceVocab = selectedLessons.includes('all') ? Object.values(this.state.allVocabulary).flat() : selectedLessons.flatMap(lesson => this.state.allVocabulary[lesson] || []); sourceVocab = sourceVocab.filter(item => typeof item === 'object' && item !== null && item.w); if (sourceVocab.length === 0) { this.showMessageBox('no_words_for_lesson'); return; } const questionCount = (difficulty === 'all') ? sourceVocab.length : Math.min(sourceVocab.length, parseInt(difficulty)); const quizVocab = this.shuffleArray(sourceVocab).slice(0, questionCount); this.initializeAndRunQuiz(quizVocab, selectedMode); },
        initializeAndRunQuiz(vocabList, mode) { if (!vocabList || vocabList.length === 0) { this.showMessageBox('no_words_for_practice'); return; } this.showLoadingScreen(); setTimeout(() => { const generatedQuestions = this.generateQuestions(vocabList, mode); if (generatedQuestions.length === 0) { this.showMessageBox('no_questions_generated'); this.resetQuiz(); return; } Object.assign(this.state, { currentQuiz: generatedQuestions, currentQuestion: 0, score: 0, streak: 0, maxStreak: 0, wrongAnswers: [], selectedAnswer: null, startTime: Date.now(), answerLog: [], maxQuestionReachedInSession: 0, }); this.elements.body.classList.add('quiz-mode-active'); this.elements.header.classList.add('hidden-during-quiz'); this.elements.controls.classList.add('hidden-during-quiz'); this.elements.quizContainer.classList.add('immersive-active'); this.showKeyboardHint(); this.showQuestion(); }, 50); },
        generateQuestions(vocabList, mode) {
            const allSourceVocabForOptions = this.shuffleArray(Object.values(this.state.allVocabulary).flat());
            let wrongOptionIndex = 0;
            const questions = vocabList.map(vocab => {
                const currentMode = mode === 'mixed' ? this.shuffleArray(['reading', 'meaning', 'usage'])[0] : mode;
                let question;
                const meaningKey = this.state.currentLanguage === 'en' ? 'm' : 'c';

                if (currentMode === 'reading' && vocab.r && vocab.w !== vocab.r) {
                    question = this.generateSingleQuestion(vocab, 'reading', 'w', 'r', allSourceVocabForOptions, wrongOptionIndex);
                
                } else if (currentMode === 'usage' && (vocab.u || vocab.e)) {
                    const sourceString = (vocab.u || vocab.e).trim();
                    const questionText = ((qs) => qs.length ? qs[Math.floor(Math.random() * qs.length)] : null)(((sourceString.match(/___/g) || []).length > 1 ? sourceString.split(/(?<=„ÄÇ)/) : [sourceString]).map(q => q.trim()).filter(Boolean));
                    if (!questionText) return null;
                    question = this.generateSingleQuestion(vocab, 'usage', questionText, 'w', allSourceVocabForOptions, wrongOptionIndex);
                
                } else {
                    const questionText = `${vocab.w}${vocab.r && vocab.w !== vocab.r ? ` (${vocab.r})` : ''}`;
                    question = this.generateSingleQuestion(vocab, 'meaning', questionText, meaningKey, allSourceVocabForOptions, wrongOptionIndex);
                }

                if (question) wrongOptionIndex = (wrongOptionIndex + 3) % allSourceVocabForOptions.length;
                return question;
            }).filter(Boolean);
            
            return this.shuffleArray(questions);
        },
        generateSingleQuestion(vocab, mode, questionKeyOrText, answerKey, shuffledPool, poolIndex) {
            const questionText = vocab[questionKeyOrText] || questionKeyOrText;
            const correctAnswer = vocab[answerKey];
            if (!correctAnswer) return null;

            const wrongOptions = new Set();
            let currentIndex = poolIndex;
            while (wrongOptions.size < 3 && currentIndex < shuffledPool.length * 2) {
                const potentialWrongVocab = shuffledPool[currentIndex % shuffledPool.length];
                // Á°Æ‰øùÊàë‰ª¨ÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÊúâÊïàÁöÑËØçÊ±áÂØπË±°ÔºåÂπ∂‰∏îÂÆÉÁöÑÁ≠îÊ°àÊñáÊú¨‰∏éÊ≠£Á°ÆÁ≠îÊ°à‰∏çÂêåÔºå‰∏î‰∏çÊòØËØçÊ±áÊú¨Ë∫´
                if (potentialWrongVocab && potentialWrongVocab.w !== vocab.w) {
                    const potentialWrongAnswer = potentialWrongVocab[answerKey];
                    if (potentialWrongAnswer && potentialWrongAnswer !== correctAnswer) {
                        // ÂÖ≥ÈîÆÂèòÂåñ1: Â≠òÂÇ®Êï¥‰∏™ËØçÊ±áÂØπË±°ÔºåËÄå‰∏ç‰ªÖ‰ªÖÊòØÁ≠îÊ°àÊñáÊú¨
                        wrongOptions.add(potentialWrongVocab);
                    }
                }
                currentIndex++;
            }

            if (wrongOptions.size < 3) return null;

            // ÂÖ≥ÈîÆÂèòÂåñ2: ÊûÑÂª∫ÈÄâÈ°πÊó∂Ôºå‰∏∫ÊØè‰∏™ÈÄâÈ°πÈôÑÂä†ÂÆåÊï¥ÁöÑ vocab ÂØπË±°
            const options = this.shuffleArray([
                { text: correctAnswer, correct: true, vocab: vocab },
                ...Array.from(wrongOptions).map(wrongVocab => ({ text: wrongVocab[answerKey], correct: false, vocab: wrongVocab }))
            ]);

            return { question: questionText, options, correctAnswer, vocab, mode };
        },

        showQuestion(options = {}) {
            // MODIFIED: Use isReviewMode as the primary flag to determine context
            const { isReviewMode = false } = options;
            clearTimeout(this.state.nextQuestionTimeoutId); 
            if (this.state.currentQuestion >= this.state.currentQuiz.length) { this.showFinalScore(); return; } 
            
            const question = this.state.currentQuiz[this.state.currentQuestion]; 
            const historyEntry = this.state.answerLog.find(log => log.questionIndex === this.state.currentQuestion); 
            
            if (!historyEntry) this.state.questionStartTime = Date.now(); 
            
            // MODIFIED: Pass the isReviewMode flag down to the HTML generator
            this.elements.quizContainer.innerHTML = this.createQuizHTML(question, historyEntry, isReviewMode); 
            this.bindQuizViewEvents(question, historyEntry); 
            this.state.isInputLocked = false; 
        },

        createQuizHTML(question, historyEntry, isReviewMode = false) {
            const progress = (this.state.currentQuestion / this.state.currentQuiz.length) * 100; 
            
            const optionsHTML = question.options.map((option, index) => { 
                let classes = 'option relative overflow-hidden p-3 md:p-5 rounded-xl cursor-pointer text-base dark:border-indigo-600 dark:text-gray-100 md:text-lg text-center disabled:cursor-not-allowed flex items-center justify-center'; 
                let textClasses = 'text-slate-700 dark:text-slate-400 font-medium'; 
                let numberClasses = 'font-bold mr-2 text-indigo-600 dark:text-indigo-300'; 
                if (historyEntry) { 
                    classes += ' disabled:opacity-100'; 
                    if (option.correct) { classes += ' !bg-green-600 !text-white !border-green-700'; textClasses = '!text-white font-medium'; numberClasses = '!text-white font-bold mr-3'; } 
                    if (!option.correct && index === historyEntry.selectedOptionIndex) { classes += ' !bg-red-600 !text-white !border-red-700 animate-[incorrectShake_0.3s_ease]'; textClasses = '!text-white font-medium'; numberClasses = '!text-white font-bold mr-3'; } 
                } 
                return `<button class="${classes}" data-index="${index}" ${historyEntry ? 'disabled' : ''}><span class="${numberClasses}">${index + 1}.</span><span class="${textClasses}">${option.text}</span></button>`; 
            }).join(''); 
            
            let feedbackHTML = '', feedbackClass = ''; 
            if (historyEntry) {
                // MODIFIED: Precise logic for inline feedback
                // Show correct feedback ONLY in review mode.
                // Show incorrect feedback always (when answered incorrectly).
                const feedbackMessage = historyEntry.isCorrect
                    ? (isReviewMode ? _t('quiz_correct_feedback') : '')
                    : _t('quiz_incorrect_feedback', { correctAnswer: question.correctAnswer });

                if (feedbackMessage) {
                    const detail = _t('quiz_feedback_detail', { word: question.vocab.w, reading_kana: question.vocab.r && question.vocab.w !== question.vocab.r ? ` (${question.vocab.r})` : '', meaning: this.state.currentLanguage === 'en' ? (question.vocab.m || question.vocab.c) : (question.vocab.c || question.vocab.m) }); 
                    feedbackClass = historyEntry.isCorrect ? 'correct-inline' : 'incorrect-inline'; 
                    feedbackHTML = feedbackMessage + `<br><small class="block mt-1 opacity-85 text-sm md:text-base text-slate-600 dark:text-slate-500">${detail}</small>`; 
                }
            }
            
            let detailedInfoHTML = '';
            // MODIFIED: Precise logic for swipe indicator and panel.
            // Render them ONLY when in review mode.
            if (historyEntry && isReviewMode) {
                detailedInfoHTML = `
                    <div id="swipeUpIndicator">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
                        </svg>
                    </div>
                    <div id="detailedInfoPanel">
                        <div id="panelHandle"></div>
                        <h3 class="text-xl font-bold mb-4 text-slate-800 dark:text-slate-200 text-center">${_t('detailed_info_title')}</h3>
                        <div class="space-y-3 overflow-y-auto">
                           ${this.createDetailedInfoContent(question)}
                        </div>
                    </div>
                `;
            }

            return ` <div class="w-full h-full flex flex-col"> <button class="exit-btn absolute top-3 right-3 w-10 h-10 bg-black/10 dark:bg-white/10 hover:bg-black/20 dark:hover:bg-white/20 text-gray-700 dark:text-gray-300 flex items-center justify-center rounded-full text-xl font-semibold z-50 transition hover:scale-110 active:scale-95">‚úï</button> <div class="mb-3 md:mb-8"> <div class="flex justify-between mb-2 font-semibold text-violet-600 dark:text-violet-500"> <span>${_t('quiz_progress', { current: this.state.currentQuestion + 1, total: this.state.currentQuiz.length })}</span> </div> <div class="progress-bar w-full h-2.5 rounded-md overflow-hidden relative"><div class="progress-fill h-full rounded-md" style="width: ${progress}%"></div></div> </div> <div class="stats flex justify-between mb-3 md:mb-5 text-sm md:text-lg font-semibold flex-wrap gap-x-4 gap-y-2"> <span class="flex items-center gap-2 text-green-600 dark:text-green-500"> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg> ${_t('quiz_correct')} ${this.state.score} </span> <span class="flex items-center gap-2 text-amber-600 dark:text-amber-500"> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.783-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" /></svg> ${_t('quiz_streak')} ${this.state.streak} </span> <span class="flex items-center gap-2 text-blue-600 dark:text-blue-500"> <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.414-1.415L11 9.586V6z" clip-rule="evenodd" /></svg> ${_t('quiz_elapsed')} <span id="timer">${historyEntry ? historyEntry.timeSpent : 0}</span>${_t('quiz_seconds')} </span> </div> <div class="question-area-wrapper"> <div class="question-content-area"> <div class="question text-3xl md:text-5xl mb-1 md:mb-2 font-semibold text-center leading-tight text-slate-800 dark:text-slate-200" id="questionText">${question.question}</div> <div id="exampleSentenceDisplay" class="text-lg px-2 text-slate-600 dark:text-slate-400"></div> </div> </div> <div class="options grid grid-cols-1 md:grid-cols-2 gap-2.5 sm:gap-3 md:gap-4"> <div id="inlineFeedback" class="inline-feedback-area ${feedbackHTML.trim() ? `show ${feedbackClass}` : ''}" aria-live="polite">${feedbackHTML}</div> ${optionsHTML} </div> </div> ${detailedInfoHTML}`; 
        },

        createDetailedInfoContent(question) {
            const historyEntry = this.state.answerLog.find(log => log.questionIndex === this.state.currentQuestion);
            if (!historyEntry) return '';

            const meaningKey = this.state.currentLanguage === 'en' ? 'm' : 'c';
            const exampleKey = 'e';

            return question.options.map((option, index) => {
                const { vocab } = option;
                if (!vocab) return ''; // Safety check

                let icon = '';
                let borderColor = 'border-slate-200 dark:border-slate-700';

                if (option.correct) {
                    icon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-green-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
                    borderColor = 'border-green-500';
                } else if (index === historyEntry.selectedOptionIndex) {
                    icon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-red-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>`;
                    borderColor = 'border-red-500';
                } else {
                    icon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-400 dark:text-slate-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>`;
                }
                
                const exampleSentence = vocab[exampleKey] || vocab.u || vocab.e;
                
                // OPTIMIZATION: Combine word and reading into w(r) format
                const wordReadingHTML = vocab.r && vocab.w !== vocab.r
                    ? `${vocab.w}<span class="text-base font-normal text-slate-500 dark:text-slate-400 ml-2">(${vocab.r})</span>`
                    : vocab.w;

                return `
                    <div class="flex items-start gap-3 p-3 bg-slate-100/50 dark:bg-slate-800/50 rounded-lg border-l-4 ${borderColor}">
                        <div class="flex-shrink-0 pt-1">${icon}</div>
                        <!-- ‰ΩøÁî® space-y-2 Êù•Áªü‰∏ÄÁÆ°ÁêÜÂûÇÁõ¥Èó¥Ë∑ù -->
                        <div class="flex-grow min-w-0 space-y-1"> 
                            <p class="text-xl font-semibold text-slate-800 dark:text-slate-100 break-words">${wordReadingHTML}</p>
                            <p class="text-slate-600 dark:text-slate-300">
                                <span class="font-semibold">${_t('detailed_info_meaning_prefix')}</span>
                                ${vocab[meaningKey] || vocab.c || vocab.m}
                            </p>
                            ${exampleSentence ? `
                            <!-- ËøôÈáåÁöÑ pt-2 ÊòØ‰∏∫‰∫ÜËæπÊ°Ü‰∏éÊñáÂ≠óÁöÑÂÜÖËæπË∑ù, space-y-2 Ë¥üË¥£ÂÆÉÂíå‰∏äÈù¢ÂÖÉÁ¥†ÁöÑÈó¥Ë∑ù -->
                            <p class="border-t border-slate-200/80 dark:border-slate-700/80 text-sm text-slate-500 dark:text-slate-400">
                                <span class="font-semibold">${_t('detailed_info_example_prefix')}</span>
                                ${exampleSentence}
                            </p>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        },
        bindQuizViewEvents(question, historyEntry) { 
            this.elements.quizContainer.querySelector('.exit-btn').addEventListener('click', () => this.resetQuiz()); 
            
            const exampleSentence = question.vocab.e || question.vocab.u; 
            if (exampleSentence) { 
                const questionTextEl = this.elements.quizContainer.querySelector('#questionText'); 
                questionTextEl.style.cursor = 'pointer'; 
                questionTextEl.title = _t('quiz_example_hint'); 
                questionTextEl.addEventListener('click', () => { 
                    const sentenceDisplay = this.elements.quizContainer.querySelector('#exampleSentenceDisplay'); 
                    sentenceDisplay.textContent = _t('example_sentence_wrapper', { example: exampleSentence }); 
                    sentenceDisplay.classList.toggle('visible'); 
                }); 
            } 
            
            if (!historyEntry) { 
                this.updateTimer(); 
                this.elements.quizContainer.querySelector('.options').addEventListener('click', e => { 
                    const button = e.target.closest('.option'); 
                    if (button && !this.state.isInputLocked) this.submitAnswer(parseInt(button.dataset.index, 10)); 
                }); 
            }
            // OPTIMIZATION: Also bind click events to the indicator and handle to show/hide the panel
            const swipeUpIndicator = this.elements.quizContainer.querySelector('#swipeUpIndicator');
            const detailedInfoPanel = this.elements.quizContainer.querySelector('#detailedInfoPanel');
            const panelHandle = this.elements.quizContainer.querySelector('#panelHandle');

            if (swipeUpIndicator && detailedInfoPanel) {
                swipeUpIndicator.addEventListener('click', () => {
                    detailedInfoPanel.classList.toggle('visible');
                });
            }

            if (panelHandle && detailedInfoPanel) {
                panelHandle.addEventListener('click', () => {
                    detailedInfoPanel.classList.remove('visible');
                });
            }
        },
        nextQuestion() { if (this.state.currentQuestion + 1 >= this.state.currentQuiz.length) { this.showFinalScore(); return; } this.state.currentQuestion++; if (this.state.currentQuestion > this.state.maxQuestionReachedInSession) { this.state.maxQuestionReachedInSession = this.state.currentQuestion; } this.showQuestion(); },
        showFinalScore() { this.resetQuizInterface(); const { score, currentQuiz, maxStreak, wrongAnswers } = this.state; const totalQuestions = currentQuiz.length; const percentage = totalQuestions > 0 ? Math.round((score / totalQuestions) * 100) : 0; const totalTime = Math.floor((Date.now() - this.state.startTime) / 1000); const avgTime = totalQuestions > 0 ? (totalTime / totalQuestions).toFixed(1) : 0; const messageKey = percentage >= 90 ? 'final_score_title_90' : percentage >= 70 ? 'final_score_title_70' : percentage >= 50 ? 'final_score_title_50' : 'final_score_title_below_50'; const emoji = percentage >= 90 ? 'üèÜ' : percentage >= 70 ? 'üéâ' : percentage >= 50 ? 'üí™' : 'üìö'; const totalTimeFormatted = totalTime >= 60 ? _t('final_score_minutes_seconds', { minutes: Math.floor(totalTime / 60), seconds: (totalTime % 60).toString().padStart(2, '0') }) : _t('final_score_seconds', { seconds: totalTime }); const wrongAnswersHtml = wrongAnswers.length > 0 ? `<div class="mt-8 text-left animate-[slideUp_0.8s_ease]"><h3 class="text-center text-2xl font-bold mb-5 text-red-600 dark:text-red-400">${_t('final_score_review_needed', { count: wrongAnswers.length })}</h3><div class="max-h-80 overflow-y-auto bg-red-50 dark:bg-red-900/30 rounded-lg p-5 border border-red-200 dark:border-red-700">${wrongAnswers.map(wrong => `<div class="mb-4 p-4 bg-white dark:bg-slate-700/50 rounded-lg border-l-4 border-red-500 shadow-md"><div class="font-bold mb-2 text-lg text-slate-800 dark:text-slate-200">${wrong.question}</div><div class="text-red-600 dark:text-red-400 mb-1">${_t('final_score_your_answer')}: ${wrong.yourAnswer}</div><div class="text-green-600 dark:text-green-400 mb-2">${_t('final_score_correct_answer')}: ${wrong.correctAnswer}</div><div class="bg-indigo-100 dark:bg-indigo-900/40 p-2 rounded-md text-sm text-slate-600 dark:text-slate-300"><strong class="dark:text-slate-100">${wrong.vocab.w}</strong> ${wrong.vocab.r && wrong.vocab.w !== wrong.vocab.r ? `(${wrong.vocab.r})` : ''}<br>${_t('final_score_original_meaning')}: ${wrong.vocab.c || wrong.vocab.m}<br>${_t('final_score_original_example')}: ${wrong.vocab.e || wrong.vocab.u || _t('final_score_no_example')}</div></div>`).join('')}</div></div>` : ''; this.elements.quizContainer.innerHTML = `<div class="final-score text-center text-3xl font-bold my-8 animate-[fadeIn_1s_ease]"><h2 class="text-4xl text-slate-800 dark:text-slate-100">${emoji} ${_t(messageKey)}</h2><div class="text-indigo-600 dark:text-indigo-400 my-5 text-2xl">${_t('final_score_correct_count', { score, total: totalQuestions })}</div><div class="text-xl mb-5 text-slate-700 dark:text-slate-300">${_t('final_score_percentage', { percentage })}</div><div class="grid grid-cols-1 md:grid-cols-3 gap-4 my-8 text-base"><div class="bg-green-50 dark:bg-green-900/30 p-4 rounded-lg"><div class="font-bold text-green-800 dark:text-green-300">${_t('final_score_max_streak')}</div><div class="text-2xl font-bold text-green-700 dark:text-green-200">${maxStreak}</div></div><div class="bg-blue-50 dark:bg-blue-900/30 p-4 rounded-lg"><div class="font-bold text-blue-800 dark:text-blue-300">${_t('final_score_total_time')}</div><div class="text-2xl font-bold text-blue-700 dark:text-blue-200">${totalTimeFormatted}</div></div><div class="bg-indigo-50 dark:bg-indigo-900/30 p-4 rounded-lg"><div class="font-bold text-indigo-800 dark:text-indigo-300">${_t('final_score_average_time')}</div><div class="text-2xl font-bold text-indigo-700 dark:text-indigo-200">${avgTime}${_t('quiz_seconds')}</div></div></div>${wrongAnswersHtml}<div class="flex gap-4 justify-center mt-8"><button id="reviewWrongBtn" class="bg-gradient-to-r from-purple-500 to-indigo-600 text-white font-semibold text-base py-3 px-8 rounded-lg transition-all duration-300 ease-in-out hover:brightness-110 active:scale-95 ${wrongAnswers.length === 0 ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105'}" ${wrongAnswers.length === 0 ? 'disabled' : ''}>${_t('final_score_review_mode')}</button><button id="restartQuizBtn" class="bg-gradient-to-r from-cyan-400 to-sky-500 text-white font-semibold text-base py-3 px-8 rounded-lg transition-all duration-300 ease-in-out hover:scale-105 hover:brightness-110 active:scale-95">${_t('final_score_restart')}</button></div></div>`; this.elements.quizContainer.querySelector('#restartQuizBtn').addEventListener('click', () => this.startQuiz()); if (wrongAnswers.length > 0) { this.elements.quizContainer.querySelector('#reviewWrongBtn').addEventListener('click', () => this.reviewWrongAnswers()); } },
        reviewWrongAnswers() { const reviewVocab = this.state.wrongAnswers.map(wrong => wrong.vocab).filter(Boolean); this.initializeAndRunQuiz(reviewVocab, 'mixed'); },
        resetQuiz() { this.resetQuizInterface(); this.renderWelcomeMessage(); },
        resetQuizInterface() { this.state.isInputLocked = false; clearTimeout(this.state.nextQuestionTimeoutId); clearInterval(this.state.timerInterval); this.elements.body.classList.remove('quiz-mode-active'); this.elements.header.classList.remove('hidden-during-quiz'); this.elements.controls.classList.remove('hidden-during-quiz'); this.elements.quizContainer.classList.remove('immersive-active'); this.hideKeyboardHint(); },
        initializeTheme() { const isSystemDark = window.matchMedia('(prefers-color-scheme: dark)').matches; this.elements.body.classList.toggle('dark', isSystemDark); this.elements.themeToggleBtn.textContent = isSystemDark ? '‚òÄÔ∏è' : 'üåô'; window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => { this.elements.body.classList.toggle('dark', e.matches); this.elements.themeToggleBtn.textContent = e.matches ? '‚òÄÔ∏è' : 'üåô'; this.updateUIForThemeChange(); }); },
        toggleTheme() { const isCurrentlyDark = this.elements.body.classList.toggle('dark'); this.elements.themeToggleBtn.textContent = isCurrentlyDark ? '‚òÄÔ∏è' : 'üåô'; this.updateUIForThemeChange(); },
        updateUIForThemeChange() { if (this.elements.body.classList.contains('quiz-mode-active')) { this.showQuestion(); } if (!this.elements.wrongWordsModal.classList.contains('hidden')) { WrongWordsManager.renderList(); WrongWordsManager.renderStatistics(); } },
        renderWelcomeMessage() { this.elements.quizContainer.innerHTML = `<div class="welcome-message text-center"><h2 class="text-2xl font-bold mb-5 text-slate-800 dark:text-slate-100">${_t('welcome_message_title')}</h2><p class="text-lg mb-8 leading-relaxed text-slate-700 dark:text-slate-300"><strong>${_t('mode_reading')}:</strong> ${_t('welcome_message_reading')}<br><strong>${_t('mode_meaning')}:</strong> ${_t('welcome_message_meaning')}<br><strong>${_t('mode_usage')}:</strong> ${_t('welcome_message_usage')}<br><strong>${_t('mode_mixed')}:</strong> ${_t('welcome_message_mixed')}</p><div class="features glass-pane mt-8 p-5 rounded-xl"><h3 class="text-center text-xl font-semibold mb-4 gradient-text">${_t('features_title')}</h3><ul class="text-left leading-relaxed list-none list-inside space-y-2 text-slate-700 dark:text-slate-300"><li>${_t('feature_1')}</li> <li>${_t('feature_2')}</li> <li>${_t('feature_3')}</li><li>${_t('feature_6')}</li> <li>${_t('feature_4')}</li> <li>${_t('feature_5')}</li><li>${_t('feature_7')}</li> <li>${_t('feature_8')}</li> <li>${_t('feature_9')}</li></ul></div></div>`; },
        showLoadingScreen() { this.elements.quizContainer.innerHTML = `<div class="flex flex-col items-center justify-center h-full"><div class="loading-spinner"></div><p class="mt-4 text-lg font-semibold">${_t('generating_questions')}</p></div>`; },
        showKeyboardHint() { if (this.state.sessionHintShown) return; this.elements.keyboardHint.classList.add('opacity-100'); setTimeout(() => this.hideKeyboardHint(), 3000); this.state.sessionHintShown = true; },
        hideKeyboardHint() { this.elements.keyboardHint.classList.remove('opacity-100'); },
        updateTimer() { clearInterval(this.state.timerInterval); const timerElement = this.elements.quizContainer.querySelector('#timer'); if (timerElement && !this.state.answerLog.some(log => log.questionIndex === this.state.currentQuestion)) { this.state.timerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - this.state.questionStartTime) / 1000); if (timerElement) timerElement.textContent = elapsed; }, 1000); } },
        handleKeyDown(e) { if (e.key === 'Escape') { if (!this.elements.wrongWordsModal.classList.contains('hidden')) WrongWordsManager.closeModal(); else if (!this.elements.messageBox.classList.contains('hidden')) this.hideMessageBox(); else if (this.elements.body.classList.contains('quiz-mode-active')) this.elements.quizContainer.querySelector('.exit-btn')?.click(); return; } if (!this.elements.body.classList.contains('quiz-mode-active') || !this.elements.wrongWordsModal.classList.contains('hidden')) return; if (e.key === 'ArrowLeft' || e.key === 'a') this.navigateToPreviousQuestion(); else if (e.key === 'ArrowRight' || e.key === 'd') this.navigateToNextQuestion(); else if (e.key >= '1' && e.key <= '4' && !this.state.isInputLocked) this.submitAnswer(parseInt(e.key) - 1); },
        
        navigateToPreviousQuestion() {
            if (this.state.currentQuestion > 0) {
                this.state.currentQuestion--;
                // MODIFIED: Explicitly state this is review mode
                this.showQuestion({ isReviewMode: true });
            }
        },

        navigateToNextQuestion() { 
            const hasBeenAnswered = this.state.answerLog.some(log => log.questionIndex === this.state.currentQuestion); 
            if (hasBeenAnswered && this.state.currentQuestion < this.state.maxQuestionReachedInSession) { 
                this.state.currentQuestion++; 
                // MODIFIED: Explicitly state this is review mode
                this.showQuestion({ isReviewMode: true }); 
            } else if (hasBeenAnswered && this.state.currentQuestion === this.state.maxQuestionReachedInSession) { 
                this.nextQuestion(); 
            } 
        },

        // ===============================================================
        // ===== END OF FINAL CORRECTED CODE (from user conversation) ====
        // ===============================================================

        handleTouchStart(e) { 
            if (this.elements.body.classList.contains('quiz-mode-active')) { 
                const touch = e.changedTouches[0]; 
                this.state.touchstartX = touch.screenX; 
                this.state.touchstartY = touch.screenY; 
                this.state.touchendX = touch.screenX; // Reset on new touch
                this.state.touchendY = touch.screenY; // Reset on new touch
                this.state.touchstartTime = Date.now(); 
            } 
        },
        handleTouchMove(e) { 
            if (!this.state.touchstartX || !this.state.touchstartY) return;
            const touch = e.changedTouches[0];
            this.state.touchendX = touch.screenX;
            this.state.touchendY = touch.screenY;
            const deltaX = this.state.touchendX - this.state.touchstartX; 
            const deltaY = this.state.touchendY - this.state.touchstartY; 
            // Prevent scrolling page if swiping horizontally
            if (Math.abs(deltaX) > Math.abs(deltaY)) { e.preventDefault(); } 
        },
        handleTouchEnd(e) { 
            if (this.state.touchstartX === 0 && this.state.touchstartY === 0) return;
            
            const deltaX = this.state.touchendX - this.state.touchstartX;
            const deltaY = this.state.touchendY - this.state.touchstartY;
            const elapsedTime = Date.now() - this.state.touchstartTime;

            const detailedInfoPanel = this.elements.quizContainer.querySelector('#detailedInfoPanel');

            if (elapsedTime < this.constants.SWIPE_TIME_THRESHOLD) {
                // Vertical Swipe for detailed panel
                if (detailedInfoPanel && Math.abs(deltaY) > this.constants.SWIPE_THRESHOLD && Math.abs(deltaY) > Math.abs(deltaX)) {
                    if (deltaY < 0) { // Swipe Up
                        detailedInfoPanel.classList.add('visible');
                    } else { // Swipe Down
                        detailedInfoPanel.classList.remove('visible');
                    }
                } 
                // Horizontal Swipe for navigation
                else if (Math.abs(deltaX) > this.constants.SWIPE_THRESHOLD && Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX < 0) { // Swipe Left
                        this.navigateToNextQuestion();
                    } else { // Swipe Right
                        this.navigateToPreviousQuestion();
                    }
                }
            }

            // Reset touch coordinates
            this.state.touchstartX = 0; 
            this.state.touchstartY = 0;
            this.state.touchendX = 0;
            this.state.touchendY = 0; 
            this.state.touchstartTime = 0; 
        },
        shuffleArray(array) { const shuffled = [...array]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled; },
    };

    document.addEventListener('DOMContentLoaded', () => {
        VocabularyApp.init();
    });
    </script>
</body>

</html>